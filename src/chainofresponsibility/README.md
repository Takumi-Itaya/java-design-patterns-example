# Chain of Responsibilityパターン

## Chain of Responsibilityパターンとは
Chain of Responsibilityパターンは、リクエストを処理するオブジェクトのチェーンを作成するデザインパターンです。各オブジェクトは、リクエストを処理するか、チェーン上の次のオブジェクトに渡すかを決定します。

## 目的
- リクエスト処理の責務を分散（1つのクラスに処理を集中させない）
- クライアントのシンプル化（どのオブジェクトが処理するかを意識しなくてよい）
- 柔軟な処理フローの実装（新しいハンドラーを追加してもコードを変更しなくてよい）

## メリット・デメリット

### メリット
- コードの再利用性が高い（各ハンドラーが独立しており、単体で利用可能）
-  拡張性が高い（新しいハンドラーを追加しても既存コードを修正する必要がない）
- クライアントコードをシンプルにできる（どのハンドラーが処理するかを意識しなくてよい）
- 処理の順序を柔軟に変更可能（動的にハンドラーを追加・削除できる）

### デメリット
- リクエストが適切に処理される保証がない（適切なハンドラーが見つからない場合、未処理のまま）
- デバッグが難しくなる（リクエストがどこで処理されるのか追跡しにくい）
- パフォーマンスのオーバーヘッド（長いチェーンを通過すると処理が遅くなる）

## 主なユースケース（具体的に）

1. **ログ処理**
   - 異なるレベルのログを異なるハンドラーで処理
   - デバッグ→情報→警告→エラーの順でログを出力
   - 例：ERROR、WARNING、INFO、DEBUG

2. **認証・認可**
   - 複数の認証方式を順番に試行
   - ユーザーの権限を順番にチェック（管理者→一般ユーザー→ゲスト）
   - 例：トークン認証、セッション認証、IP認証

3. **エラー処理**
   - 異なる種類のエラーを異なるハンドラーで処理
   - 例：ネットワークエラー、データベースエラー、バリデーションエラー

4. **イベント処理**
   - イベントを複数のハンドラーで順次処理
   - 例：GUIイベント、システムイベント

5. **リクエスト処理**
   - Web アプリのリクエストをミドルウェアで順に処理（認証→圧縮→キャッシュ）

## 実装例の説明
このサンプルコードでは、以下のような構造でChain of Responsibilityパターンを実装しています：

1. **Handler（インターフェース）**
   - リクエスト処理の基本インターフェース
   - 次のハンドラーの設定とリクエスト処理を定義

2. **ConcreteHandler（具象クラス）**
   - 具体的なリクエスト処理を実装
   - 処理できない場合は次のハンドラーに委譲

## よくある質問（FAQ）

### Q: Chain of ResponsibilityパターンとDecoratorパターンの違いは何ですか？
A: Chain of Responsibilityパターンは複数のオブジェクトでリクエストを処理するのに対し、Decoratorパターンは単一のオブジェクトに機能を追加します。

### Q: Chain of Responsibilityパターンはいつ使用すべきですか？
A: 以下のような場合に使用すべきです：
- リクエストの送信者と受信者を分離したい場合
- 複数のオブジェクトでリクエストを処理したい場合
- リクエストの処理を柔軟に変更したい場合

### Q: Chain of Responsibilityパターンの実装コストは高いですか？
A: 初期の設計と実装には若干のコストがかかりますが、システムの柔軟性と保守性の向上により、そのコストは十分に回収できます。特に、システムの規模が大きくなるほど、そのメリットは顕著になります。 