# Java シングルトンパターン実装例

ここでは Java におけるシングルトンデザインパターンの様々な実装方法を示すサンプルコードを提供します。

## シングルトンパターンとは

シングルトンパターンはクラスのインスタンスが 1 つだけ存在することを保証し、そのインスタンスへのグローバルなアクセスポイントを提供するデザインパターンです。

## 目的

クラスのインスタンスを 1 つだけ作成し、それをグローバルにアクセス可能にすること

## メリット・デメリット

**メリット**

- インスタンスを一元管理することで、データの整合性を保ちやすい
- 不要なインスタンスの生成を防ぎ、リソースを節約する
- グローバルにアクセスすることができる

**デメリット**

- どこからでもアクセスできるため、コードの追跡が難しくなり可読性が低下する
- モックや DI が使いづらく単体テストが難しくなる
- スレッドセーフにしないと競合が発生し、複数のインスタンスが生成する可能性がある

## 主なユースケース

1. **設定管理**

   アプリケーション全体で共有する設定情報を管理する場合、一つのインスタンスのみが存在し、複数のスレッドから安全にアクセスできる必要があります。

   - 設定ファイルの読み込み (appConfig.get("db_url") など)
   - 環境変数の管理

2. **ロギング**

   ログ出力を行うクラスは、複数のスレッドから同時に呼び出される可能性があります。シングルトンにすることで、ログの管理を一元化し、ファイル書き込みの競合を防ぐことができます。

   - Logger.getInstance().log("message")

3. **データベース接続管理**

   データベース接続の管理をシングルトンにすることで、不要な接続の作成を防ぎ、パフォーマンスを向上させることができます。

   - DatabaseConnectionPool.getInstance().getConnection()

4. **スレッドプール管理**

   スレッドプールをシングルトンにすることで、複数のスレッドが共通のスレッドプールを使用できるようにします。

   - ThreadPool.getInstance().execute(task)

5. **キャッシュ管理**

   アプリケーション全体でキャッシュを共有する場合、シングルトンにすることで、データの整合性を保ちつつ、不要なメモリ消費を防ぐことができます。

   - _CacheManager.getInstance().get("user_123")_

## 実装例

このプロジェクトでは以下の 4 種類のシングルトン実装を提供しています：

1. **基本的なシングルトン** (`Singleton.java`)

   - 最もシンプルな実装
   - マルチスレッド環境では問題が発生する可能性あり

2. **スレッドセーフなシングルトン** (`ThreadSafeSingleton.java`)

   - 二重チェックロッキング（Double-Checked Locking）を使用
   - マルチスレッド環境でも安全

3. **Enum を使用したシングルトン** (`EnumSingleton.java`)

   - Joshua Bloch の「Effective Java」で推奨される方法
   - シリアライゼーションやリフレクションに対しても安全

4. **静的内部クラスを使用したシングルトン** (`StaticInnerClassSingleton.java`)
   - 遅延初期化（Lazy Initialization）とスレッドセーフを両立
   - シンプルで効率的な実装
   - クラスロード時にインスタンスが生成されない

## よくある質問（FAQ）

Q:　**なぜ 2 重チェックロッキングを使用するのか**

A: 通常のシングルトンでは `synchronized` を使うと、毎回のアクセスでロックがかかるため、パフォーマンスが低下します。しかし、二重チェックロッキングを使えば、インスタンスがすでに生成されている場合はロックを回避できるため、スレッドセーフかつ高速な実装が可能になります。

Q: **`volatile`が必要な理由**

A: `volatile`をつけないと、JVM の最適化によって、インスタンスの作成途中の状態が他のスレッドに見えてしまう可能性があり、他のスレッドが未完成のインスタンスにアクセスしてしまう可能性があります。なので`volatile`をつけることで、この不完全な状態を防ぎ、スレッド間で正しい順序で値を読み書きできるようにすることができます。

Q: **`synchronized`を使うパターンと静的内部クラスを使うパターンどちらを使うべきか**

A: 一般的には静的内部クラスを使う方が推奨される。メリットとして以下の 3 つがある。

- シンプルで可読性が高い
- パフォーマンスが高い（クラスローディング時の仕組みを利用し、余計な同期処理が不要）

だが、静的内部クラスを使うパターンは内部クラスの仕組みを理解していないと、直感的にわかりにくい。2 重チェックロッキングを用いるのであれば、静的内部クラスを使用した方が個人的には良い。
