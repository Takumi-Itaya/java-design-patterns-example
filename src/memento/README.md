# Mementoパターン

## Mementoパターンとは
Mementoパターンは、オブジェクトの内部状態を保存し、後でその状態に戻すことができるようにするデザインパターンです。オブジェクトのカプセル化を破ることなく、オブジェクトの状態を保存・復元することができます。

## 目的
- オブジェクトの内部状態を保存する
- オブジェクトの状態を後で復元できるようにする
-  オブジェクトのカプセル化を維持しつつ、外部から状態管理を可能にする
- 状態の保存と復元のロジックを分離する

## メリット・デメリット

### メリット
- オブジェクトのカプセル化を守りつつ、状態の保存と復元が可能
- 状態の保存と復元のロジックを分離できる
- 複数の状態を保存できる
- 履歴管理（Undo/Redo）を簡単に実装できる

### デメリット
- メモリ使用量が増加する可能性がある
- 状態の保存と復元に時間がかかる可能性がある
- システムの複雑さが増加する可能性がある

## 主なユースケース（具体的に）

1. **テキストエディタ**
   - 編集履歴の保存と復元
   - 例：元に戻す（Undo）機能

2. **ゲーム**
   - セーブポイントの保存と復元
   - 例：ゲームの進行状況の保存

3. **データベース**
   - トランザクションのロールバック
   - 例：データの変更履歴の管理

4. **GUIアプリケーション**
   - フォームの状態の保存と復元
   - 例：入力フォームの状態管理

5. **設定の変更を一時保存**
   - アプリケーションの設定変更の一時保存と復元

## 実装例の説明
このサンプルコードでは、以下のような構造でMementoパターンを実装しています：

1. **Memento（メメント）**
   - オブジェクトの内部状態を保存するクラス
   - Mementoクラス

2. **Originator（発信者）**
   - 状態を保存・復元するオブジェクト
   - GameStateクラス

3. **Caretaker（管理者）**
   - メメントを保存・管理するクラス
   - GameStateCaretakerクラス

## よくある質問（FAQ）

### Q: MementoパターンとCommandパターンの違いは何ですか？
A: Mementoパターンはオブジェクトの状態を保存・復元するのに対し、Commandパターンは操作をオブジェクトとしてカプセル化します。

### Q: Mementoパターンはいつ使用すべきですか？
A: 以下のような場合に使用すべきです：
- オブジェクトの状態を保存・復元したい場合
- オブジェクトのカプセル化を維持したい場合
- 状態の変更履歴を管理したい場合

### Q: Mementoパターンの実装コストは高いですか？
A: メモリ使用量の増加や実装の複雑さが増す可能性がありますが、状態の保存と復元の柔軟性が向上し、長期的にはコストを回収できる場合があります。 