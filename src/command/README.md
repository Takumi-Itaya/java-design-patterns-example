# Commandパターン

## Commandパターンとは
Commandパターンは、リクエストをオブジェクトとしてカプセル化するデザインパターンです。これにより、リクエストの発行者と実行者を分離し、リクエストのパラメータ化、キューイング、ログ記録、取り消し操作などを可能にします。

## 目的
- リクエストの発行者と実行者を分離する
- リクエストをオブジェクトとしてカプセル化する
- 操作の履歴管理、取り消し、やり直し機能を実現する
- 複雑な操作を単純なコマンドの組み合わせで実現する

## メリット・デメリット

### メリット
- 処理の実行と依存関係を分離（Invoker は Receiver を意識しなくてよい）
- 操作の履歴管理が容易
- コマンドの組み合わせによる複雑な操作の実現
- 拡張性と再利用性の向上
- リクエストを遅延実行・キューイングできる（非同期処理に適している）

### デメリット
- クラス数の増加
- システムの複雑さが増加する可能性
- 単純な操作に対して過剰な設計になる可能性

## 主なユースケース（具体的に）

1. **GUIアプリケーション**
   - ボタンクリック、メニュー選択などのアクション
   - 例：エディタの「コピー」「貼り付け」「元に戻す」機能

2. **マクロ機能**
   - 複数の操作を一つのコマンドとして記録・再生
   - 例：テキストエディタのマクロ、ゲームの操作マクロ

3. **トランザクション処理**
   - データベースの操作をコマンドとして実装
   - 例：CRUD操作、トランザクションのロールバック

4. **スケジューリング**
   - 後で実行するコマンドのキュー管理
   - タスクをキューに追加し、順番に実行
   - 例：バッチ処理、タスクスケジューラ

5. **リモート操作**
   - ネットワーク越しのコマンド実行
   - 例：リモートコントロール、分散システム

## 実装例の説明
このサンプルコードでは、以下のような構造でCommandパターンを実装しています：

1. **Command（インターフェース）**
   - 全てのコマンドが実装するインターフェース
   - execute()とundo()メソッドを定義

2. **ConcreteCommand（具象クラス）**
   - 具体的なコマンドを実装
   - LightOnCommandとLightOffCommand

3. **Receiver（レシーバー）**
   - 実際の処理を行うクラス
   - Lightクラス

4. **Invoker（インボーカー）**
   - コマンドの実行を要求するクラス
   - RemoteControlとRemoteControlWithUndo

## よくある質問（FAQ）

### Q: CommandパターンとStrategyパターンの違いは何ですか？
A: Commandパターンはリクエストをオブジェクトとしてカプセル化し、実行の履歴管理などを可能にするのに対し、Strategyパターンはアルゴリズムをカプセル化し、実行時に切り替え可能にするものです。

### Q: Commandパターンはいつ使用すべきですか？
A: 以下のような場合に使用すべきです：
- リクエストの発行者と実行者を分離したい場合
- 操作の履歴管理や取り消し機能が必要な場合
- 複雑な操作を単純なコマンドの組み合わせで実現したい場合

### Q: Commandパターンの実装コストは高いですか？
A: 小規模なシステムでは過剰な設計になる可能性がありますが、大規模なシステムや将来の拡張を考慮する場合は、柔軟性と保守性の向上によりコストを回収できます。 