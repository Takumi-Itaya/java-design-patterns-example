# Bridge パターン

## Bridge パターンとは

Bridge パターンは、抽象化と実装を分離し、それぞれを独立して変更できるようにするデザインパターンです。これにより、実装の詳細を変更することなく、抽象化を変更することができ、またその逆も可能になります。

## 目的

- 抽象化と実装を分離し、それぞれを独立して変更できるようにする
- 実装の詳細を変更することなく、抽象化を変更できるようにする
- クラスの継承階層を減らし、より柔軟な設計を実現する

## メリット・デメリット

### メリット

1. **実装の独立性**

   - 例：図形描画システムで、描画 API を変更しても図形の定義は変更不要
   - 例：データベースアクセス層を変更しても、ビジネスロジックは変更不要

2. **拡張性の向上**

   - 例：新しい描画 API を追加する際に、既存の図形クラスを変更する必要がない
   - 例：新しいデータベースをサポートする際に、既存のビジネスロジックを変更する必要がない

3. **保守性の向上**
   - 例：描画 API のバグ修正が図形の定義に影響を与えない
   - 例：データベースの最適化がビジネスロジックに影響を与えない

### デメリット

1. **設計の複雑性**

   - 例：図形描画システムの場合、抽象化と実装の 2 つの階層を管理する必要がある
   - 例：データベースアクセス層の場合、インターフェースと実装の関係を適切に設計する必要がある

2. **オーバーヘッド**
   - 例：描画 API の呼び出しに若干のオーバーヘッドが発生する可能性がある
   - 例：データベースアクセス層の追加により、パフォーマンスに影響が出る可能性がある

## 主なユースケース

1. **GUI フレームワーク**

   - ウィンドウシステムとウィンドウの実装を分離
   - 例：Java Swing の Look and Feel 機能

2. **データベースアクセス層**

   - データベース操作の抽象化と実装を分離
   - 例：ORM フレームワークでのデータベースプロバイダーの切り替え

3. **描画システム**

   - 図形の定義と描画方法を分離
   - 例：SVG レンダリングエンジンの実装

4. **プラットフォーム依存機能**
   - プラットフォーム固有の実装を抽象化
   - 例：ファイルシステムアクセスの実装

## 実装例の説明

このサンプルコードでは、以下のような構造で Bridge パターンを実装しています：

1. **抽象化（Abstraction）**

   - `Shape`抽象クラス：図形の基本インターフェース
   - `Circle`と`Rectangle`：具体的な図形クラス

2. **実装（Implementation）**

   - `DrawingAPI`インターフェース：描画操作の基本インターフェース
   - `DrawingAPI1`と`DrawingAPI2`：具体的な描画実装

3. **Bridge**
   - `Shape`クラスが`DrawingAPI`を保持し、実装と抽象化を接続

## よくある質問（FAQ）

### Q: Bridge パターンと Adapter パターンの違いは何ですか？

A: Bridge パターンは設計時から抽象化と実装を分離することを目的とし、Adapter パターンは既存のインターフェースを新しいインターフェースに適合させることを目的とします。

### Q: Bridge パターンはいつ使用すべきですか？

A: 以下のような場合に使用すべきです：

- 抽象化と実装を独立して変更する必要がある場合
- 実装の詳細を変更することなく、抽象化を変更する必要がある場合
- クラスの継承階層が深くなりすぎている場合

### Q: Bridge パターンの実装コストは高いですか？

A: 初期の設計と実装には若干のコストがかかりますが、長期的な保守性と拡張性の向上により、そのコストは十分に回収できます。特に、システムの規模が大きくなるほど、そのメリットは顕著になります。
